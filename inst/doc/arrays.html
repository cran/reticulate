<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title>Arrays in R and Python</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Arrays in R and Python</h1>



<p>Dense data are stored contiguously in memory, addressed by a single index (the memory address). Array memory ordering schemes translate that single index into multiple indices corresponding to the array coordinates. For example, matrices have two indices: rows and columns. Three-d arrays have three, and so on.</p>
<div id="column-major-order" class="section level2">
<h2>Column-major order</h2>
<p><em>Column-major</em> order is used by Fortran, Matlab, R, and most underlying core linear algebra libraries (BLAS). Sequential address locations are translated into array coordinates <em>i, j, k, …</em> so that the first array coordinates vary most rapidly with address, the next array coordinates less rapidly, and so on. For instance, four address locations 1, 2, 3, 4 are translated into a two by two matrix coordinate system <em>(i, j)</em> as:</p>
<pre><code>address   i  j
  1       1  1
  2       2  1
  3       1  2
  4       2  2</code></pre>
<p>The phrase <em>column-major</em> comes from the matrix example, where sequentially addressed data are laid out sequentially along columns of the matrix.</p>
<p>The concept of “row” and “column” don’t directly apply to n-d arrays, but the same idea holds. For instance the R language lays out sequential addresses from 1, 2, …, 8, into a 2x2x2 3-d array as:</p>
<pre><code>address   i  j  k
  1       1  1  1
  2       2  1  1
  3       1  2  1
  4       2  2  1
  5       1  1  2
  6       2  1  2
  7       1  2  2
  8       2  2  2</code></pre>
<p>Consider the 3-d case shown above. Given array dimensions <em>d<sub>1</sub>=2, d<sub>2</sub>=2, d<sub>3</sub>=2</em>, a formula that takes 1-based coordinates <em>i, j, k</em> and returns address location <em>a</em> is <br /> <em>a = i + (j - 1) * d<sub>1</sub> + (k - 1) * d<sub>2</sub> * d<sub>1</sub></em>.</p>
</div>
<div id="row-major-order" class="section level2">
<h2>Row-major order</h2>
<p>Row-major ordering is a different translation between sequential address indices and array coordinates, instead laying sequential data in memory across rows in matrices. Row-major ordering is sometimes called “C” style ordering and column-major ordering “Fortran” style. Python/NumPy refers to the orderings in array flags as C_CONTIGUOUS and F_CONTIGUOUS, respectively. For instance address locations 1, 2, 3, 4 are translated into a 2x2 matrix coordinate system <em>(i, j)</em> as:</p>
<pre><code>address   i  j
  1       1  1
  2       1  2
  3       2  1
  4       2  2</code></pre>
<p>Efficient wrappers to BLAS routines exist for row-major ordered arrays. For completeness, here is a 2x2x2 3-d example layout:</p>
<pre><code>address   i  j  k
  1       1  1  1
  2       1  1  2
  3       1  2  1
  4       1  2  2
  5       2  1  1
  6       2  1  2
  7       2  2  1
  8       2  2  2</code></pre>
<p>And similarly to above a formula for this example that converts these 1-based array coordinates to address indices is: <br /> <em>a = k + (j - 1) * d<sub>3</sub> + (i - 1) * d<sub>3</sub> * d<sub>2</sub></em>.</p>
<p>See the following notes for a general formula for row- and column-order coordinate to address mapping, but note the use of zero-based indexing.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order#Address_calculation_in_general" class="uri">https://en.wikipedia.org/wiki/Row-_and_column-major_order#Address_calculation_in_general</a></li>
<li><a href="https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html" class="uri">https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html</a></li>
</ul>
</div>
<div id="python" class="section level2">
<h2>Python</h2>
<p>The Python NumPy library is very general. It can use <em>either</em> row-major or column-major ordered arrays, but it defaults to row-major ordering. NumPy also supports sophisticated <em>views</em> of data with custom strides across non-contiguous regions of memory.</p>
</div>
<div id="displaying-arrays" class="section level2">
<h2>Displaying arrays</h2>
<p>R displays array data with unambiguously-labeled coordinate indices. Python doesn’t show this and displays n-d array data in different order than R (making matters somewhat confusing for R users). Consider the following example that creates and displays identical 4x3x2 arrays in R and Python:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">24</span>, <span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>))

## , , 1
##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
## 
## , , 2
##      [,1] [,2] [,3]
## [1,]   13   17   21
## [2,]   14   18   22
## [3,]   15   19   23
## [4,]   16   20   24</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
np.reshape(np.arange(<span class="dv">1</span>,<span class="dv">25</span>), (<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>), <span class="st">&quot;F&quot;</span>)

<span class="co">## array([[[ 1, 13],</span>
<span class="co">##         [ 5, 17],</span>
<span class="co">##         [ 9, 21]],</span>
<span class="co">##</span>
<span class="co">##        [[ 2, 14],</span>
<span class="co">##         [ 6, 18],</span>
<span class="co">##         [10, 22]],</span>
<span class="co">##</span>
<span class="co">##        [[ 3, 15],</span>
<span class="co">##         [ 7, 19],</span>
<span class="co">##         [11, 23]],</span>
<span class="co">##</span>
<span class="co">##        [[ 4, 16],</span>
<span class="co">##         [ 8, 20],</span>
<span class="co">##         [12, 24]]])</span></code></pre></div>
<p>It’s easier to know which coordinates go where in R because they are labeled. Python, using column-major ordering, displays the same thing but in a different order where the first indices are grouped together in order. To see that these arrays are, in fact, <strong>the same</strong>, let’s pick out values along just the first “row”, that is values with a first index of 1 (R) or 0 (Python):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">24</span>, <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>))[<span class="dv">1</span>,, ,drop=<span class="ot">FALSE</span>]

## , , 1
##      [,1] [,2] [,3]
## [1,]    1    5    9
## 
## , , 2
##      [,1] [,2] [,3]
## [1,]   13   17   21</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">np.reshape(np.arange(<span class="dv">1</span>,<span class="dv">25</span>), (<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>), <span class="st">&quot;F&quot;</span>)[<span class="dv">0</span>]

<span class="co">## array([[ 1, 13],</span>
<span class="co">##        [ 5, 17],</span>
<span class="co">##        [ 9, 21]])</span></code></pre></div>
<p>I specified R’s <code>drop=FALSE</code> argument to preserve array dimensionality above. If we use <code>drop=TRUE</code> (the default) then R returns a 3x2 array in column-major order–exactly the same result as Python above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">24</span>, <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>))[<span class="dv">1</span>,, ,drop=<span class="ot">TRUE</span>]

##      [,1] [,2]
## [1,]    1   13
## [2,]    5   17
## [3,]    9   21</code></pre></div>
<p>Note that the Python result is a special view of the original array data, not a copy. In this case it’s not stored in contiguous memory addresses and is neither really row- nor column-major. This is shown in the array flags:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">np.reshape(np.arange(<span class="dv">1</span>,<span class="dv">25</span>), (<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>), <span class="st">&quot;F&quot;</span>)[<span class="dv">0</span>].flags

<span class="co">##  C_CONTIGUOUS : False</span>
<span class="co">##  F_CONTIGUOUS : False</span>
<span class="co">##  OWNDATA : False</span>
<span class="co">##  WRITEABLE : True</span>
<span class="co">##  ALIGNED : True</span>
<span class="co">##  UPDATEIFCOPY : False</span></code></pre></div>
</div>
<div id="reticulate-with-care" class="section level2">
<h2>Reticulate with care</h2>
<p>The reticulate package lets us easily mix R and Python code and data. Recall that R represents all dense arrays in column-major order but Python/NumPy can represent dense arrays much more generally. That difference warrants attention and can easily lead to confusion!</p>
<p>Remember the following things when working with R and Python arrays, especially <em>n</em>-d arrays with <em>n &gt; 2</em>.</p>
<ol style="list-style-type: decimal">
<li>Dense R arrays are presented to Python/NumPy as column-major NumPy arrays.</li>
<li><em>All</em> NumPy arrays (column-major, row-major, otherwise) are presented to R as column-major arrays, because that is the only kind of dense array that R understands.</li>
<li>R and Python print arrays differently.</li>
</ol>
<p>Also worth knowing:</p>
<ul>
<li>Python array indices are zero-based, R indices are 1-based.</li>
<li>R arrays are only copied to Python when they need to be, otherwise data are shared.</li>
<li>Python arrays are <em>always</em> copied when moved into R arrays. This can sometimes lead to three copies of any one array in memory at any one time (at the moment this was written). Future versions will reduce that copy overhead to two.</li>
</ul>
<p>Point number 3. introduces the most potential confusion. Let’s look at some examples to explore these points.</p>
<p>The following example creates a 2x2x2 array in Python using native NumPy row-major ordering and imports it into R. Despite the fact that they print out differently, they are in fact the same.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(reticulate)
np &lt;-<span class="st"> </span><span class="kw">import</span>(<span class="st">&quot;numpy&quot;</span>, <span class="dt">convert=</span><span class="ot">FALSE</span>)
(x &lt;-<span class="st"> </span>np$<span class="kw">arange</span>(<span class="dv">1</span>, <span class="dv">9</span>)$<span class="kw">reshape</span>(2L, 2L, 2L))

## [[[ 1.  2.]
##   [ 3.  4.]]
## 
##  [[ 5.  6.]
##   [ 7.  8.]]]

(y &lt;-<span class="st"> </span><span class="kw">py_to_r</span>(x))

## , , 1
##      [,1] [,2]
## [1,]    1    3
## [2,]    5    7
## 
## , , 2
##      [,1] [,2]
## [1,]    2    4
## [2,]    6    8</code></pre></div>
<p>Wait a minute! They look different! But remember Python’s print order is different. The first “rows” (first index values) are grouped together. Let’s pull out elements with first index of 1 in the R result, with and without dropping the unused dimension to show precisely what we’re indexing here:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y[<span class="dv">1</span>,,, drop=<span class="ot">FALSE</span>]

## , , 1
##      [,1] [,2]
## [1,]    1    3
## 
## , , 2
##      [,1] [,2]
## [1,]    2    4

y[<span class="dv">1</span>,,, drop=<span class="ot">TRUE</span>]

##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4</code></pre></div>
<p>Note that this is the same as the first block printed in the Python output above! These arrays really are the same in Python and R, respectively. Their apparent differences are merely a result of printing.</p>
<div id="another-example" class="section level3">
<h3>Another example</h3>
<p>Let’s look at this again with another example, this time with an array with different lengths along each dimension to make things even more clear (hopefully). Consider the following 4x3x2 array constructed in Python in row-major order:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">np &lt;-<span class="st"> </span><span class="kw">import</span>(<span class="st">&quot;numpy&quot;</span>, <span class="dt">convert=</span><span class="ot">FALSE</span>)
(x &lt;-<span class="st"> </span>np$<span class="kw">reshape</span>(np$<span class="kw">arange</span>(<span class="dv">1</span>, <span class="dv">25</span>), <span class="kw">c</span>(4L, 3L, 2L)))

## [[[  1.   2.]
##   [  3.   4.]
##   [  5.   6.]]
## 
##  [[  7.   8.]
##   [  9.  10.]
##   [ 11.  12.]]
## 
##  [[ 13.  14.]
##   [ 15.  16.]
##   [ 17.  18.]]
## 
##  [[ 19.  20.]
##   [ 21.  22.]
##   [ 23.  24.]]]

(y &lt;-<span class="st"> </span><span class="kw">py_to_r</span>(x))

## , , 1
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    7    9   11
## [3,]   13   15   17
## [4,]   19   21   23
## 
## , , 2
##      [,1] [,2] [,3]
## [1,]    2    4    6
## [2,]    8   10   12
## [3,]   14   16   18
## [4,]   20   22   24</code></pre></div>
<p>Again, they look quite different but the R and Python arrays are really the same. Let’s pick out the sub-array with third index = 0 (Python), equivalently the third index = 1 in R.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">np$<span class="kw">take</span>(x, 0L, 2L)

## [[  1.   3.   5.]
##  [  7.   9.  11.]
##  [ 13.  15.  17.]
##  [ 19.  21.  23.]]

y[, , <span class="dv">1</span>]

##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    7    9   11
## [3,]   13   15   17
## [4,]   19   21   23</code></pre></div>
<p>The NumPy <code>take()</code> function is equivalent in this example to the Python notation <code>x[:, :, 0]</code>; that is, entries with third dimension index = 0. (See <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html" class="uri">https://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html</a>.)</p>
<p>The corresponding R notation, <code>y[, , 1]</code>, returns the same thing in this example: a 4x3 matrix.</p>
<p>Despite different internal memory ordering, and particularly despite awkward differences in printing arrays, the arrays are the same and are indexed the same way in each language respectively.</p>
</div>
</div>
<div id="what-about-going-from-r-column-major-arrays-to-python" class="section level2">
<h2>What about going from R column-major arrays to Python?</h2>
<p>The previous examples focused on row-major arrays natively constructed in Python. Let’s see what happens when we start with column-major arrays from R and work with them in Python.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(y &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">24</span>, <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>)))  <span class="co"># In R</span>

## , , 1
##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
## 
## , , 2
##      [,1] [,2] [,3]
## [1,]   13   17   21
## [2,]   14   18   22
## [3,]   15   19   23
## [4,]   16   20   24

(x &lt;-<span class="st"> </span>np$<span class="kw">array</span>(y))              <span class="co"># and now in Python</span>

## [[[ 1 13]
##   [ 5 17]
##   [ 9 21]]
## 
##  [[ 2 14]
##   [ 6 18]
##   [10 22]]
## 
##  [[ 3 15]
##   [ 7 19]
##   [11 23]]
## 
##  [[ 4 16]
##   [ 8 20]
##   [12 24]]]</code></pre></div>
<p>Note that the Python version takes advantage of NumPy’s extraordinary flexibility and preserves R’s column-major ordering:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x$flags

##   C_CONTIGUOUS : False
##   F_CONTIGUOUS : True
##   OWNDATA : True
##   WRITEABLE : True
##   ALIGNED : True
##   UPDATEIFCOPY : False</code></pre></div>
<p>You can probably tell already from the previous sections that these arrays are the same, and obey the same indexing conventions. The next example selects a subarray such that the third index of each array is 0 (Python) or 1 (R):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y[, , <span class="dv">1</span>]

##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12

np$<span class="kw">take</span>(x, 0L, 2L)

## [[ 1  5  9]
##  [ 2  6 10]
##  [ 3  7 11]
##  [ 4  8 12]]</code></pre></div>
<p>It’s important to remember that the order is preserved from Python when copying an array result back into R:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">py_to_r</span>(np$<span class="kw">take</span>(x, 0L, 2L))

##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12</code></pre></div>
<p><em><strong>The upshot is that arrays created by either R or Python are indexed exactly the same in either language.</strong></em></p>
<div id="but-the-array-i-created-in-r-ends-up-transposed-compared-to-ones-i-create-in-python" class="section level3">
<h3>But the array I created in R ends up transposed compared to ones I create in Python?</h3>
<p>Right. That’s just a simple consequence of the default column-major and row-major formats used in R and NumPy respectively. You are always free to use R’s column-major format directly in Python, for example using the “F” flag below (for Fortran):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">np$<span class="kw">reshape</span>(np$<span class="kw">arange</span>(<span class="dv">1</span>, <span class="dv">25</span>), <span class="kw">c</span>(4L, 3L, 2L), <span class="st">&quot;F&quot;</span>)

## [[[  1.  13.]
##   [  5.  17.]
##   [  9.  21.]]
## 
##  [[  2.  14.]
##   [  6.  18.]
##   [ 10.  22.]]
## 
##  [[  3.  15.]
##   [  7.  19.]
##   [ 11.  23.]]
## 
##  [[  4.  16.]
##   [  8.  20.]
##   [ 12.  24.]]]</code></pre></div>
<p>Note that the result is just like the one we got starting from R above.</p>
<p>Re-arranging R arrays into row-major order requires more work. R is less flexible than Python and we can’t explicitly change R’s memory order representation. When the array is a matrix when we can simply use <code>byrow=TRUE</code>. In the n-d array case, a portion of the problem can be reduced to using <code>byrow=TRUE</code> followed by judicious index permutation with <code>aperm()</code>. Here is one somewhat inefficient example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">aperm</span>(<span class="kw">array</span>(<span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">24</span>, <span class="kw">c</span>(<span class="dv">3</span> *<span class="st"> </span><span class="dv">4</span>, <span class="dv">2</span>), <span class="dt">byrow=</span><span class="ot">TRUE</span>),
           <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>)), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>))</code></pre></div>
<p>See the last section below for a different example.</p>
<p>We can verify that the above ugly expression exactly reproduces a NumPy row-major array by subtracting our R array from a native Python one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">np &lt;-<span class="st"> </span><span class="kw">import</span>(<span class="st">&quot;numpy&quot;</span>, <span class="dt">convert=</span><span class="ot">FALSE</span>)
o  &lt;-<span class="st"> </span><span class="kw">import</span>(<span class="st">&quot;operator&quot;</span>, <span class="dt">convert=</span><span class="ot">FALSE</span>)

o$<span class="kw">sub</span>(np$<span class="kw">arange</span>(<span class="dv">1</span>, <span class="dv">25</span>)$<span class="kw">reshape</span>(4L, 3L, 2L), np$<span class="kw">array</span>(y))

## [[[ 0.  0.]
##   [ 0.  0.]
##   [ 0.  0.]]
## 
##  [[ 0.  0.]
##   [ 0.  0.]
##   [ 0.  0.]]
## 
##  [[ 0.  0.]
##   [ 0.  0.]
##   [ 0.  0.]]
## 
##  [[ 0.  0.]
##   [ 0.  0.]
##   [ 0.  0.]]]</code></pre></div>
<p>The above NumPy arrays are the same, their element-wise difference is zero.</p>
</div>
</div>
<div id="other-differences-warranting-caution" class="section level2">
<h2>Other differences warranting caution</h2>
<p>It’s worth noting that analogs of R’s <code>apply()</code> function in Python behave differently. The following excellent Mathesaurus reference <a href="http://mathesaurus.sourceforge.net/r-numpy.html" class="uri">http://mathesaurus.sourceforge.net/r-numpy.html</a> applies well to matrices and vectors, but is misleading for <em>n</em>-d arrays with <em>n &gt; 2</em>.</p>
<p>In particular, Mathesaurus says that if <em>a</em> is a <em>matrix</em>, then the sum of each column in Python may be computed by <code>a.sum(0)</code>, and in R (among other possible ways) by <code>apply(a, 2, sum)</code>. Although correct for matrices, this is in general not quite right. A more precise R analog of NumPy’s <code>a.sum(0)</code> is <code>apply(a, dim(a)[-1], sum)</code>. In other words, <code>a.sum(0)</code> means sum over the first dimension, returning an array of the same dimensions as <em>a</em> but with the first dimension removed.</p>
<p>It’s easy to be confused by this, so let’s see an example using a 4x3x2 array, first in Python:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(reticulate)
np &lt;-<span class="st"> </span><span class="kw">import</span>(<span class="st">&quot;numpy&quot;</span>, <span class="dt">convert=</span><span class="ot">FALSE</span>)
x  &lt;-<span class="st"> </span>np$<span class="kw">arange</span>(<span class="dv">1</span>, <span class="dv">25</span>)$<span class="kw">reshape</span>(<span class="kw">c</span>(4L, 3L, 2L))
x$<span class="kw">sum</span>(<span class="dv">0</span>)   <span class="co"># N. B. a 3x2 matrix!</span>

## [[ 40.  44.]
##  [ 48.  52.]
##  [ 56.  60.]]

<span class="co"># N. B. A tuple() object is required here (NumPy vectors won't work)</span>
x$<span class="kw">sum</span>(<span class="kw">tuple</span>(1L, 2L))

## [  21.   57.   93.  129.]</code></pre></div>
<p>And now the corresponding sums in R:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">py_to_r</span>(x)
<span class="kw">apply</span>(y, <span class="kw">dim</span>(y)[-<span class="dv">1</span>], sum)

##      [,1] [,2] [,3]
## [1,]   40   48   56
## [2,]   44   52   60

<span class="kw">apply</span>(y, <span class="dv">1</span>, sum)

## [1]  21  57  93 129</code></pre></div>
</div>
<div id="addressing-an-issue-that-came-up" class="section level1">
<h1>Addressing an issue that came up</h1>
<p>These notes were prepared in response to a tensorflow issue now in the reticulate package <a href="https://github.com/rstudio/reticulate/issues/9" class="uri">https://github.com/rstudio/reticulate/issues/9</a>. The issue directly gets to a common source of confusion with n-d arrays in R and Python and how they are printed and stored. A lightly-edited reproduction of the reference Python code in the issue appears below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tensorflow)
np   &lt;-<span class="st"> </span><span class="kw">import</span>(<span class="st">&quot;numpy&quot;</span>, <span class="dt">convert=</span><span class="ot">FALSE</span>)
a    &lt;-<span class="st"> </span>np$<span class="kw">arange</span>(<span class="dv">1</span>, <span class="dv">9</span>)$<span class="kw">reshape</span>(<span class="kw">c</span>(2L, 2L, 2L))
b    &lt;-<span class="st"> </span>np$<span class="kw">arange</span>(<span class="dv">1</span>, <span class="dv">5</span>)$<span class="kw">reshape</span>(<span class="kw">c</span>(2L, 2L, 1L))
c    &lt;-<span class="st"> </span>tf$<span class="kw">matmul</span>(tf$<span class="kw">constant</span>(a), tf$<span class="kw">constant</span>(b))
tf$<span class="kw">Session</span>()$<span class="kw">run</span>(c)

## , , 1
##      [,1] [,2]
## [1,]    5   11
## [2,]   39   53</code></pre></div>
<p>The issue goes on to reproduce the example using R-generated arrays as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">A &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">4</span>, <span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">byrow=</span>T), <span class="kw">matrix</span>(<span class="dv">5</span>:<span class="dv">8</span>, <span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">byrow=</span>T))
A &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">unlist</span>(A), <span class="dt">dim=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>))</code></pre></div>
<p>However, already at this point we see that the R-generated array <em>A</em> is not the same as the above array <em>a</em> by comparing <em>a</em> with <code>np$array(A)</code> below.</p>
<p>However, we can see how it can be easy to make the mistake that they are the same simply because of the way the arrays are printed! The R array looks superficially the same as the printed Python array.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(a)

## [[[ 1.  2.]
##   [ 3.  4.]]
## 
##  [[ 5.  6.]
##   [ 7.  8.]]]


<span class="kw">print</span>(np$<span class="kw">array</span>(A))

## [[[1 5]
##   [2 6]]
## 
##  [[3 7]
##   [4 8]]]


<span class="kw">print</span>(A)

## , , 1
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## 
## , , 2
##      [,1] [,2]
## [1,]    5    6
## [2,]    7    8</code></pre></div>
<p>Instead, we need to construct the R array <em>A</em> differently to match the row-major order of Python, discussed in the previous sections. We can use many approaches including:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(A &lt;-<span class="st"> </span>np$<span class="kw">array</span>(<span class="kw">aperm</span>(<span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">8</span>, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>)), <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>))))

## [[[1 2]
##   [3 4]]
## 
##  [[5 6]
##   [7 8]]]</code></pre></div>
<p>With similar care ordering the values in the <em>b</em> array we can finish replicating the example in R (with the same result as the reference Python example above).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">A &lt;-<span class="st"> </span>np$<span class="kw">array</span>(<span class="kw">aperm</span>(<span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">8</span>, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>)), <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>)))
B &lt;-<span class="st"> </span>np$<span class="kw">array</span>(<span class="kw">aperm</span>(<span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">4</span>, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>)), <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>)))
C &lt;-<span class="st"> </span>tf$<span class="kw">matmul</span>(tf$<span class="kw">constant</span>(A), tf$<span class="kw">constant</span>(B))
tf$<span class="kw">Session</span>()$<span class="kw">run</span>(C)

## , , 1
##      [,1] [,2]
## [1,]    5   11
## [2,]   39   53</code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
